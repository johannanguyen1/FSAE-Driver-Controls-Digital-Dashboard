// Dashboard 2025 Code

#include <mcp_can.h>  // necessary for CAN Protocol communication commands
#include <SPI.h>      // necessary for serial communication between the SPI devices and the MicroController

// Define the pins between the MCP2515 Board and the MicroController
#define CS_Pin 10
#define INTRPT_Pin 9  // or 0

// Variables for data metrics
float voltage;
float coolTemp;
unsigned int engnSpeed;  // RPM will be stored here as an integer
unsigned int gear = 0;  // currently not set up
float wheelSpeed;

// Flag to indicate CAN initialization
bool can_initialized = false;

// Create an instance of MCP_CAN with the CS pin
MCP_CAN CAN(CS_Pin);

void setup() {
  // Input and Output pin setups
  pinMode(CS_Pin, OUTPUT);
  pinMode(INTRPT_Pin, INPUT);

  // Initialize Serial for debugging
  Serial.begin(9600);
  while (!Serial);
  Serial.println("CAN Receiver Callback");

  // Start the CAN bus at 250 kbps (using MCP_CAN's specific start command)
  if (CAN.begin(MCP_ANY, CAN_250KBPS, MCP_8MHZ) == CAN_OK) {
    Serial.println("CAN Started");
    can_initialized = true;
  } else {
    Serial.println("Starting CAN failed!");
    while (1);  // Stop if CAN initialization fails
  }

  // Set CAN mode to normal operation
  CAN.setMode(MCP_NORMAL);

}

// Helper function to convert CAN buffer to float
float extractFloatFromBuffer(unsigned char* buf) {
  union {
    uint32_t bits;
    float number;
  } data;

  data.bits = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
  return data.number;
}


void loop() {
  // Check for new CAN messages
  if (CAN.checkReceive() == CAN_MSGAVAIL) {
    receiveCANMessage();
  }

  // CAN re-initialization logic (if needed)
  if (!can_initialized) {
    Serial.println("Attempting to restart CAN...");
    if (CAN.begin(MCP_ANY, CAN_250KBPS, MCP_8MHZ) == CAN_OK) {
      Serial.println("CAN Restarted");
      can_initialized = true;
    } else {
      Serial.println("CAN Restart failed");
      delay(1000);  // Wait before retrying
    }
  }


  // If it doesn't work:
  // NOTE: Make sure these are the ONLYYYYYY print statements
  // Serial1 --> Serial
  // write --> print
  Serial1.print("rpm.val=" + String(engnSpeed)); Serial1.write(0xff); Serial1.write(0xff); Serial1.write(0xff);
  Serial1.print("gear.val=" + String(gear)); Serial1.write(0xff); Serial1.write(0xff); Serial1.write(0xff);

}

void receiveCANMessage() {
  unsigned long canId;
  unsigned char len = 0;
  unsigned char buf[8];

  CAN.readMsgBuf(&canId, &len, buf);

  Serial.print("Received CAN message with ID: ");
  Serial.print(canId, HEX);
  Serial.print(" (Decimal: ");
  Serial.print(canId);
  Serial.print(") (Length: ");
  Serial.print(len);
  Serial.println(" bytes");

  // for debugging
  Serial.print("Raw data bytes: ");
  for (int i = 0; i < len; i++) {
    Serial.print(buf[i], HEX);
    Serial.print(" ");
  }
  Serial.println();

  if (canId == 0x702) {  // Assuming 0x702 is the CAN ID for RPM data
      engnSpeed = extractFloatFromBuffer(buf);  // Convert to 16-bit integer for RPM
      Serial.print("Engine Speed (RPM): ");
      Serial.println(engnSpeed / 6 + 2);  // Print the RPM value
  }
  // else if (canId == 0x700) {  // Coolant Temperature CAN ID
  //   memcpy(&coolTemp, buf, sizeof(float));
  //   Serial.print("Coolant Temperature: ");
  //   Serial.println(coolTemp);
  // }
  // else if (canId == 0x701) {  // Voltage CAN ID
  //   memcpy(&voltage, buf, sizeof(float));
  //   Serial.print("Voltage: ");
  //   Serial.println(voltage);
  // }
  // else if (canId == 0x648) {  // Wheel Speed CAN ID
  //   memcpy(&wheelSpeed, buf, sizeof(float));
  //   Serial.print("Wheel Speed: ");
  //   Serial.println(wheelSpeed);
  // } else {
  //     Serial.println("Unexpected CAN ID or message length");
  // }

  Serial.println();
}
