// Dashboard 2025 Code

#include <mcp_can.h>  // necessary for CAN Protocol communication commands
#include <SPI.h>      // necessary for serial communication between the SPI devices and the MicroController

// Define the pins between the MCP2515 Board and the MicroController
#define CS_Pin 10
#define INTRPT_Pin 9  // or 0

// Variables for data metrics
float voltage;
float coolTemp;
unsigned int engnSpeed;  // RPM will be stored here as an integer
float wheelSpeed;

// Flag to indicate CAN initialization
bool can_initialized = false;

// Create an instance of MCP_CAN with the CS pin
MCP_CAN CAN(CS_Pin);

void setup() {
  // Input and Output pin setups
  pinMode(CS_Pin, OUTPUT);
  pinMode(INTRPT_Pin, INPUT);

  // Initialize Serial for debugging
  Serial.begin(9600);
  while (!Serial);
  Serial.println("CAN Receiver Callback");

  // Start the CAN bus at 250 kbps (using MCP_CAN's specific start command)
  if (CAN.begin(MCP_ANY, CAN_250KBPS, MCP_8MHZ) == CAN_OK) {
    Serial.println("CAN Started");
    can_initialized = true;
  } else {
    Serial.println("Starting CAN failed!");
    while (1);  // Stop if CAN initialization fails
  }

  // Set CAN mode to normal operation
  CAN.setMode(MCP_NORMAL);
}

void loop() {
  // Check for new CAN messages
  if (CAN.checkReceive() == CAN_MSGAVAIL) {
    receiveCANMessage();
  }

  // CAN re-initialization logic (if needed)
  if (!can_initialized) {
    Serial.println("Attempting to restart CAN...");
    if (CAN.begin(MCP_ANY, CAN_250KBPS, MCP_8MHZ) == CAN_OK) {
      Serial.println("CAN Restarted");
      can_initialized = true;
    } else {
      Serial.println("CAN Restart failed");
      delay(1000);  // Wait before retrying
    }
  }
}

void receiveCANMessage() {
  unsigned long canId;
  unsigned char len = 0;
  unsigned char buf[8];

  // Read message into buffer and get CAN ID
  CAN.readMsgBuf(&canId, &len, buf);

  Serial.print("Received CAN message with ID: ");
  Serial.print(canId, HEX);
  Serial.print(" (Decimal: ");
  Serial.print(canId);
  Serial.print(") (Length: ");
  Serial.print(len);
  Serial.println(" bytes)");

  // Process data based on CAN ID
  if (canId == 0x702) {  // Assuming 0x702 is the CAN ID for RPM data
    if (len == 8) {  // Expecting 8 bytes for RPM
      unsigned long long rpm;
      memcpy(&rpm, buf, sizeof(rpm)); // Copy data from buffer

      // If the RPM is sent as a raw integer, we may need to divide or scale it
      // Check for endianness, depending on how it's sent
      // Example: Convert from bytes to a value (this is often necessary)
      rpm = (buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24)); // Adjust as necessary for endianness
      // If your RPM is scaled (e.g., if the sender sends RPM in thousands)
      // Adjust accordingly, e.g., if it is sent in thousands, do:
      // rpm /= 1000;

      Serial.print("Engine Speed (RPM): ");
      Serial.println(rpm); // Print the RPM value
    } else {
      Serial.println("Unexpected length for RPM data");
    }
  }

  // Uncomment and handle the other CAN IDs if needed
  /*
  else if (canId == 0x700) {  // Coolant Temperature CAN ID
    memcpy(&coolTemp, buf, sizeof(float));
    Serial.print("Coolant Temperature: ");
    Serial.println(coolTemp);
  }
  else if (canId == 0x701) {  // Voltage CAN ID
    memcpy(&voltage, buf, sizeof(float));
    Serial.print("Voltage: ");
    Serial.println(voltage);
  }
  else if (canId == 0x648) {  // Wheel Speed CAN ID
    memcpy(&wheelSpeed, buf, sizeof(float));
    Serial.print("Wheel Speed: ");
    Serial.println(wheelSpeed);
  }
  */

  Serial.println();
}

